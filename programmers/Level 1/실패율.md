# 실패율
* [링크](https://school.programmers.co.kr/learn/courses/30/lessons/42889)
* 시간 : 26분

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

class Solution {
    public int[] solution(int N, int[] stages) {
        int[] playerCount = new int[N + 2]; //각 스테이지마다 플레이어 수
        for (int stage : stages) {
            playerCount[stage] += 1;
        }

        int player = stages.length;         //전체 플레이어는 stages의 길이
        List<Stage> stageList = new ArrayList<>();
        for (int index = 1 ; index <= N; index++) {
            double rate = (double) playerCount[index] / player;
            player -= playerCount[index];       //rate를 구한 후 남은 player의 수를 줄임
            stageList.add(new Stage(index, rate));
        }

        Collections.sort(stageList, Collections.reverseOrder());

        int[] answer = new int[N];
        for (int i = 0; i < N; i++) {
            answer[i] = stageList.get(i).index;
        }
        return answer;
    }

    class Stage implements Comparable<Stage> {
        public int index;
        public double rate;

        public Stage(int index, double rate) {
            this.index = index;
            this.rate = rate;
        }

        @Override
        public int compareTo(Stage o) {
            if (rate < o.rate) {
                return -1;
            } else if (rate > o.rate) {
                return 1;
            }else return 0;
        }
    }
}
```
* Stage의 수가 N+2임을 알아내는 것이 중요했다
* Class로 빼서 Comparable 인터페이스를 구현하는 것이 계산하기 좀 더 쉬운 방법이었다.


## 다른 사람 답안
```java
import java.util.*;

class Solution {
    public int[] solution(int N, int[] stages) {
        //스테이지에는 1 ~ N+1 까지 담겨있기 때문에 N+2 길이로 배열 생성
        int[] count = new int[N+2];

        //각 스테이지마다 카운트합
        for (int stage : stages) {
            count[stage] += 1;
        }

        //맵을 만듦
        HashMap<Integer, Double> stageMap = new HashMap<>();
        double player = stages.length;  //전체 사람 수는 stages의 길이

        //스테이지의 수만큼 반복하며 실패율 계산
        for (int i = 1; i <= N; i++) {
            if (player == 0) {
                stageMap.put(i, 0.0); 
                continue;   //만약 사람이 없다면 실패율 = 0 -> 아래 과정은 건너띔
            }
            
            //
            double currStagePlayer = count[i]; 
            stageMap.put(i, currStagePlayer / player);  
            player -= currStagePlayer; 
        }

        return stageMap.entrySet().stream()
            .sorted((o1, o2) -> Double.compare(o2.getValue(), o1.getValue()))   //내림차순으로 정렬할 수 있도록 함
            .mapToInt(Map.Entry::getKey)
            .toArray();
    }
}
```
* Map으로 만들면 스테이지 번호와 실패율을 동시에 저장할 수 있다.
* 그리고 반환할 때 stream을 사용해서 정렬 후 반환하면 코드가 더 깔끔하다.

# 배운 것
1. 주어지는 조건에서 필요한 것을 빠르게 알아내는 능력이 중요하다. 이번에 Stage의 수가 N+2임을 아는데 시간이 오래 걸렸고 이를 모르고 구현하면서 런타임 에러가 발생했는데 아마 OutBoundOfIndex 에러일 것이다.
2. 무조건 클래스로 빼서 하는 것이 좋은 것은 아니다. 이번에 클래스로 빼서 코드를 작성했지만 비교해야할 것이 하나라면 Map을 사용하는 것도 좋아보인다