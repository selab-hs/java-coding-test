# 수 찾기
* 시간 : 25분
* 풀이 방법 확인

```java
import java.io.*;
import java.util.*;

public class Main {
    private static BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
    private static BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(System.out));

    public static void main(String[] args) throws IOException {
        StringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine());
        int n = Integer.parseInt(stringTokenizer.nextToken());
        int[] A = new int[n];
        stringTokenizer = new StringTokenizer(bufferedReader.readLine());
        for (int i = 0; i < n; i++) {
            A[i] = Integer.parseInt(stringTokenizer.nextToken());
        }

        stringTokenizer = new StringTokenizer(bufferedReader.readLine());
        int m = Integer.parseInt(stringTokenizer.nextToken());
        stringTokenizer = new StringTokenizer(bufferedReader.readLine());
        int[] B = new int[m];
        for (int i = 0; i < m; i++) {
            B[i] = Integer.parseInt(stringTokenizer.nextToken());
        }


        Arrays.sort(A);

        for (int num : B) {
            if (binaryFind(num, A, 0, A.length - 1)) bufferedWriter.write("1\n");
            else bufferedWriter.write("0\n");
        }

        bufferedWriter.flush();
    }


    private static boolean binaryFind(int num, int[] arr, int start, int end) {
        if (start > end) return false;

        int mid = (start + end) / 2;
        if(num == arr[mid]) {
            return true;
        }else if(num < arr[mid]){
            return binaryFind(num, arr, start, mid - 1);
        }else return binaryFind(num, arr, mid + 1, end);
    }
}
```

처음에 List의 contains로 해결하려 했으나 시간 초과가 떠서 풀이 방법을 확인해보니 이진 탐색이 있었다. 그래서 이진 탐색 알고리즘을 적용해서 풀어보았다.